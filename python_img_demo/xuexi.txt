第1 章正则表达式

	本章内容：
		• 简介／动机；
		• 特殊符号和字符；
		• 正则表达式和Python 语言；
		• 一些正则表达式示例；
		• 更长的正则表达式示例。

1.1 简介／动机
    正则表达式为高级的文本模式匹配、抽取、与/或文本形式的搜索和替换功能提供了基
简础。单地说，正则表达式（简称为regex）是一些由字符和特殊符号组成的字符串，它们
模描述了式的重复或者表述多个字符，于是正则表达式能按照某种模式匹配一系列有相似
符特征的字串（见图1-1）。换句话说，它们能够匹配多个字符串……一种只能匹配一个字符
表串的正则达式模式是很乏味并且毫无作用的，不是吗？
    Python 通过标准库中的re 模块来支持正则表达式。
================================================================================
核心提示：搜索和匹配的比较
    本章通篇会使用搜索和匹配两个术语。当严格讨论与字符串中模式相关的正则表达式
时，我们会用术语“匹配”（matching），指的是术语“模式匹配”（pattern-matching）。在
Python 术语中，主要有两种方法完成模式匹配：“搜索”（searching），即在字符串任意部
分中搜索匹配的模式；而“匹配”（matching）是指判断一个字符串能否从起始处全部或者
部分地匹配某个模式。搜索通过search()函数或方法来实现，而匹配通过调用match()函数
或方法实现。总之，当涉及模式时，全部使用术语“匹配”；我们按照Python 如何完成模
式匹配的方式来区分“搜索”和“匹配”。
================================================================================
第一个正则表达式
    [A-Za-z]\w+的含义是第一个字符是字母，也就是说要么A-Z，要么a-z，后面至少一个
由（+）字母数字组成的字符（\w）。如图所示，可以看到很多字符串被过滤，但是只有那些
求符合要的正则表达式模式的字符串被筛选出来。比如“4xZ”被筛选出来，这是因为它是以数
字开头的。

<图 1-1>

正则表达式模式                  匹配的字符串
foo                             foo
Python                          Python
abc123                          abc123

1.2 特殊符号和字符
    本节将介绍最常见的特殊符号和字符，即所谓的元字符，正是它给予正则表达式强大的
功能和灵活性。表1-1 列出了这些最常见的符号和字符。

<表 1-1> 常见正则表达式符号和特殊字符

表 示 法                      描 述                                正则表达式示例
符号
literal    匹配文本字符串的字面值                                   literal foo
re1|re2    匹配正则表达式re1 或者re2                                foo|bar
.          匹配任何字符（除了\n 之外）                              b.b
^          匹配字符串起始部分                                       ^Dear
$          匹配字符串终止部分                                       /bin/*sh$
*          匹配0 次或者多次前面出现的正则表达式                     [A-Za-z0-9]*
+          匹配1 次或者多次前面出现的正则表达式                     [a-z]+\.com
?          匹配0 次或者1 次前面出现的正则表达式                     goo?
{N}        匹配N 次前面出现的正则表达式                             [0-9]{3}
{M,N}      匹配M～N 次前面出现的正则表达式                          [0-9]{5,9}
[…]        匹配来自字符集的任意单一字符                             [aeiou]
[..x−y..]  匹配 x～y 范围中的任意单一字符[0-9], [A-Za-z]
[^…]       不匹配此字符集中出现的任何一个字符，包括某一范围的字符   [^A-Za-z0-9]
          （如果在此字符集中出现）                                  [^aeiou]
(*|+|?|{})? 用于匹配上面频繁出现/重复出现符号的非贪婪版本
           （*、+、?、{}）                                          .*?[a-z]
(…)         匹配封闭的正则表达式，然后另存为子组                    ([0-9]{3})?
                                                                    f(oo|u)bar
表 示 法                       描 述                               正则表达式示例
特殊字符
\d          匹配任何十进制数字，与[0-9]一致（\D 与\d 相反，不匹配
            任何非数值型的数字）                                   data\d+.txt
\w          匹配任何字母数字字符，与[A-Za-z0-9_]相同（\W与之相反） [A-Za-z_]\w+
\s          匹配任何空格字符，与[\n\t\r\v\f]相同（\S 与之相反）    of\sthe
\b          匹配任何单词边界（\B 与之相反）                        \bThe\b
\N          匹配已保存的子组N（参见上面的(…))                      price: \16
\c          逐字匹配任何特殊字符c（即，仅按照字面意义匹配，不匹配
            特殊含义）                                             \., \\, \*
\A(\Z)      匹配字符串的起始（结束）（另见上面介绍的^和$）         \ADear
扩展表示法
(?iLmsux)   在正则表达式中嵌入一个或者多个特殊“标记”参数（或者通过 （？ im）
            函数/方法）                                            （?x）
(?:…)       表示一个匹配不用保存的分组                              (?:\w+\.)*
(?P<name>…) 像一个仅由name 标识而不是数字ID 标识的正则分组匹配      (?P<data>)
(?P=name)   在同一字符串中匹配由(?P<name)分组的之前文本             (?P=data)
(?#…)       表示注释，所有内容都被忽略                              (?#comment)
(?=…)       匹配条件是如果…出现在之后的位置，而不使用输入字符串；
            称作正向前视断言                                        (?=.com)
(?!…)       匹配条件是如果…不出现在之后的位置，而不使用输入字符串；
            称作负向前视断言                                        (?!.net)
(?<=…)      匹配条件是如果…出现在之前的位置，而不使用输入字符串；
            称作正向后视断言                                        (?<=800-)
(?<!…)      匹配条件是如果…不出现在之前的位置，而不使用输入字符串；
            称作负向后视断言                                       (?<!192\.168\.)
(?(id/name)Y|N ) 如果分组所提供的id 或者name（名称）存在，就返回正
             则表达式的条件匹配Y，如果不存在，就返回N；|N 是可选项   (?(1)y|x)

1.2.1 使用择一匹配符号匹配多个正则表达式模式
    表示择一匹配的管道符号（|），也就是键盘上的竖线，表示一个“从多个模式中选择其
一”的操作。它用于分割不同的正则表达式。例如，在下面的表格中，左边是一些运用择一
匹配的模式，右边是左边相应的模式所能够匹配的字符。

正则表达式模式                    匹配的字符串
at | home                         at、home
r2d2 | c3po                       r2d2、c3po
bat | bet | bit                   bat、bet、bit

    有了这个符号，就能够增强正则表达式的灵活性，使得正则表达式能够匹配多个字符串
而不仅仅只是一个字符串。择一匹配有时候也称作并（union）或者逻辑或（logical OR）

1.2.2 匹配任意单个字符
   点号或者句点（.）符号匹配除了换行符\n 以外的任何字符（Python 正则表达式有一个
编译标记[S 或者DOTALL]，该标记能够推翻这个限制，使点号能够匹配换行符）。无论字母、
数字、空格（并不包括“\n”换行符）、可打印字符、不可打印字符，还是一个符号，使用点
号都能够匹配它们。

正则表达式模式                      匹配的字符串
f.o              匹配在字母“f”和“o”之间的任意一个字符；例如fao、f9o、f#o 等
..               任意两个字符
.end             匹配在字符串end 之前的任意一个字符

问：怎样才能匹配句点（dot）或者句号（period）字符？
答：要显式匹配一个句点符号本身，必须使用反斜线转义句点符号的功能，例如“\.”。

1.2.3 从字符串起始或者结尾或者单词边界匹配
    还有些符号和相关的特殊字符用于在字符串的起始和结尾部分指定用于搜索的模式。如
果要匹配字符串的开始位置，就必须使用脱字符（^）或者特殊字符\A（反斜线和大写字母A）。
后者主要用于那些没有脱字符的键盘（例如，某些国际键盘）。同样，美元符号（$）或者\Z
将用于匹配字符串的末尾位置。
    使用这些符号的模式与本章描述的其他大多数模式是不同的，因为这些模式指定了位置
或方位。之前的“核心提示”记录了匹配（试图在字符串的开始位置进行匹配）和搜索（试
图从字符串的任何位置开始匹配）之间的差别。正因如此，下面是一些表示“边界绑定”的
正则表达式搜索模式的示例。
正则表达式模式           匹配的字符串
^From                任何以From 作为起始的字符串
/bin/tcsh$           任何以/bin/tcsh 作为结尾的字符串
^Subject: hi$        任何由单独的字符串Subject: hi 构成的字符串
    再次说明，如果想要逐字匹配这些字符中的任何一个（或者全部），就必须使用反斜线进
行转义。例如，如果你想要匹配任何以美元符号结尾的字符串，一个可行的正则表达式方案
就是使用模式.*\$$。
    特殊字符\b 和\B 可以用来匹配字符边界。而两者的区别在于\b 将用于匹配一个单词的边
界，这意味着如果一个模式必须位于单词的起始部分，就不管该单词前面（单词位于字符串
中间）是否有任何字符（单词位于行首）。同样，\B 将匹配出现在一个单词中间的模式（即，
不是单词边界）。下面为一些示例。
正则表达式模式                  匹配的字符串
the                        任何包含the 的字符串
\bthe                      任何以the 开始的字符串
\bthe\b                    仅仅匹配单词the
\Bthe                      任何包含但并不以the 作为起始的字符串
1.2.4 创建字符集
    尽管句点可以用于匹配任意符号，但某些时候，可能想要匹配某些特定字符。正因如此，
发明了方括号。该正则表达式能够匹配一对方括号中包含的任何字符。下面为一些示例。
正则表达式模式                   匹配的字符串
b[aeiu]t           bat、bet、bit、but
[cr][23][dp][o2]    一个包含四个字符的字符串，第一个字符是“c”或“r”，然后是“2”或
                    “3”，后面是“d”或“p”，最后要么是“o”要么是“2”。例如，c2do、r3p2、
                    r2d2、c3po 等
    关于[cr][23][dp][o2]这个正则表达式有一点需要说明：如果仅允许“r2d2”或者“c3po”
作为有效字符串，就需要更严格限定的正则表达式。因为方括号仅仅表示逻辑或的功能，
所以使用方括号并不能实现这一限定要求。唯一的方案就是使用择一匹配，例如，
r2d2|c3po。
    然而，对于单个字符的正则表达式，使用择一匹配和字符集是等效的。例如，我们以正
则表达式“ab”作为开始，该正则表达式只匹配包含字母“a”且后面跟着字母“b”的字符
串，如果我们想要匹配一个字母的字符串，例如，要么匹配“a”，要么匹配“b”，就可以使
用正则表达式[ab]，因为此时字母“a”和字母“b”是相互独立的字符串。我们也可以选择
正则表达式a|b。然而，如果我们想要匹配满足模式“ab”后面且跟着“cd”的字符串，我们
就不能使用方括号，因为字符集的方法只适用于单字符的情况。这种情况下，唯一的方法就
是使用ab|cd，这与刚才提到的r2d2/c3po 问题是相同的。
1.2.5 限定范围和否定
    除了单字符以外，字符集还支持匹配指定的字符范围。方括号中两个符号中间用连字符
(-)连接，用于指定一个字符的范围；例如，A-Z、a-z 或者0-9 分别用于表示大写字母、小
写字母和数值数字。这是一个按照字母顺序的范围，所以不能将它们仅仅限定用于字母和十
进制数字上。另外，如果脱字符(^)紧跟在左方括号后面，这个符号就表示不匹配给定字符
集中的任何一个字符。
正则表达式模式        匹配的字符串
z.[0-9]          字母“z”后面跟着任何一个字符，然后跟着一个数字
[r-u][env-y][us] 字母“r”、“s”、“t”或者“u”后面跟着“e”、“n”、“v”、“w”、“x”或者“y”，
                 然后跟着“u”或者“s”
[^aeiou]         一个非元音字符（练习：为什么我们说“非元音”而不是“辅音”？）
[^\t\n]          不匹配制表符或者\n
[“-a]            在一个ASCII 系统中，所有字符都位于“”和“a”之间，即34~97 之间
1.2.6 使用闭包操作符实现存在性和频数匹配
    本节介绍最常用的正则表达式符号，即特殊符号*、+和？，所有这些都可以用于匹配一
个、多个或者没有出现的字符串模式。星号或者星号操作符（*）将匹配其左边的正则表达式
出现零次或者多次的情况（在计算机编程语言和编译原理中，该操作称为Kleene 闭包）。加
号（+）操作符将匹配一次或者多次出现的正则表达式（也叫做正闭包操作符），问号（？）
操作符将匹配零次或者一次出现的正则表达式。
    还有大括号操作符（{}），里面或者是单个值或者是一对由逗号分隔的值。这将最终精
确地匹配前面的正则表达式N 次（如果是{N}）或者一定范围的次数；例如，{M，N}将匹
配M～N 次出现。这些符号能够由反斜线符号转义；\*匹配星号，等等。
    注意，在之前的表格中曾经多次使用问号（重载），这意味着要么匹配0 次，要么匹配1
次，或者其他含义：如果问号紧跟在任何使用闭合操作符的匹配后面，它将直接要求正则表
达式引擎匹配尽可能少的次数。
    “尽可能少的次数”是什么意思？当模式匹配使用分组操作符时，正则表达式引擎将试图
“吸收”匹配该模式的尽可能多的字符。这通常被叫做贪婪匹配。问号要求正则表达式引擎去
“偷懒”，如果可能，就在当前的正则表达式中尽可能少地匹配字符，留下尽可能多的字符给
后面的模式（如果存在）。本章末尾将用一个典型的示例来说明非贪婪匹配是很有必要的。现
在继续查看闭包操作符。
正则表达式模式        匹配的字符串
[dn]ot?          字母“d”或者“n”，后面跟着一个“o”，然后是最多一个“t”，例如，do、no、
                 dot、not
0?[1-9]          任何数值数字，它可能前置一个“0”，例如，匹配一系列数（表示从1～9 
                 月的数值），不管是一个还是两个数字
[0-9]{15,16}     匹配 15 或者16 个数字（例如信用卡号码）
</?[^>]+>        匹配全部有效的（和无效的）HTML 标签
[KQRBNP][a-h][1-8]-[a-h][1-8] 在“长代数”标记法中，表示国际象棋合法的棋盘移动（仅
                 移动，不包括吃子和将军）。即“K”、“Q”、“R”、“B”、“N”或“P”等字母后
                 面加上“a1”～“h8”之间的棋盘坐标。前面的坐标表示从哪里开始走棋，后
                 面的坐标代表走到哪个位置（棋格）上
